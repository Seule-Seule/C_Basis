# 内存四区

* 指针指向谁就把谁的地址赋值给指针。
* 指针变量和它所指向的内存空间不一样！
* 尽量不要在临时去分配内存（尤其是栈上），要注意变量的生命周期！
* main函数中定义在栈上的遍量可以在main调用的函数中使用，反之不行。
* 没有内存，哪来的指针，指针来自于内存的抽象。
* 系统栈大多是向下的，但栈上的数组地址都是递增的。
* 


# 指针专题
- 指针也是一种数据类型。
  - 指针变量中存着地址值。
  - 指针占4字节（byte）。
  - `*p`操作内存,`p`操作指针变量`a`。
  - `*p`在等号左边，写内存;`*p`在等号右边，从内存中读数据。
  - 不断给指针赋值，就是在不停的改变指针的指向。
  - `p++`只改变指针指向，不改变内存。
  - 指针的数据类型是指它指向的内存空间的指针类型。

## 野指针

  - `free`后一定要重新给指针赋值`NULL`，`free`不改变指针变量的值，只释放内存，不重置指针产生野指针。

## 字面量
  - 肯定不在堆也不在栈！！不知道在代码区还是静态常量区。

## 指针应用条件
  - 定义两个变量实参（需要在操作的值）和形参（辅助修改的值）； `int a;int *p = NULL;`
  - 参数指定（用形参代替实参）. `p =&a;`
  - 使用形参修改实参。`*p = xx;`

## 字符串
  - `buf[] = "abcd";`
  - `strlen(buf) = 4;`  // 不包括字符数组的"\0"
  - `sizeof(buf) = 5;`  // 字符数组所占内存空间大小，包括结尾的"\0"
  - `p[]` 本质上等与`*p`,` p[]` 中的`p`不能改变，`*p`中的`p`可以改变。

## const
  - `const int a;`和 `int const b;`是一样的。
  - 
   - `const char *p; `  // 指针所指的内存空间不能修改
   - `char * const p;`  // 指针变量本身不能被修改
   - `const char * const p;`  // 指针变量和指针所指的内存空间都不能被修改

## 数组

- 元素类型角度，数组是相同类型的变量的有序集合
- 内存角度，连续的一大片内存空间

- `a[100] = {0};`

- 数组地址   // &a     &a+1 --> 跳了100*4 个字节
- 数组首元素地址  // a   a+1 -->跳了4个字节
- 数组类型
- 数组类型变量
- 数组指针类型
- 数组指针类型变量

## 多维数组本质

|          数组参数          |       等效的指针参数       |
| :------------------------: | :------------------------: |
|   一维数组  `char a[10]`   |       指针 `char *p`       |
|   指针数组 `char *a[10]`   |   指针的指针 `char **p`    |
| 二维数组 `char a\[10][10]` | 数组的指针 `char (*a)[10]` |



### 指针数组的常用应用

- 菜单栏
- 命令行输入

### 指针数组的自我结束能力

- 指针数组结尾元素置`NULL`,用于判断结束
- `char *p[]= {'1111','\0'}` <=>`char *p[]= {'1111',0}`<=>`char *p[]= {'1111',NULL}`

# 结构体

## 结构体类型及变量

- 类型定义、变量定义
- 结构体变量初始化及引用

## 结构体做函数参数

- 结构体做参数
- 结构体指针做参数

## 结构体的深拷贝和浅拷贝

- C提供结构体浅拷贝，即当结构体中有指针指向堆区时，不会申请堆区内存，而是机械的拷贝指针变量的值。
- 如果需要深拷贝，需要自己分配堆区的内存。
- 求结构体成员相对结构体首地址偏移量
- 反之，通过结构体成员地址-偏移量 求结构体首地址

## 文件操作

### 文件分类

- 文本文件（ASCII文件）
- 流文件

### 文件操作

- 字符操作`fgetc()`读一个字符，`fputc()`写一个字符，`feof()`判断文件结束

# 内存四区

* 指针指向谁就把谁的地址赋值给指针。
* 指针变量和它所指向的内存空间不一样！
* 尽量不要在临时去分配内存（尤其是栈上），要注意变量的生命周期！
* main函数中定义在栈上的遍量可以在main调用的函数中使用，反之不行。
* 没有内存，哪来的指针，指针来自于内存的抽象。
* 系统栈大多是向下的，但栈上的数组地址都是递增的。
* 


# 指针专题
- 指针也是一种数据类型。
  - 指针变量中存着地址值。
  - 指针占4字节（byte）。
  - `*p`操作内存,`p`操作指针变量`a`。
  - `*p`在等号左边，写内存;`*p`在等号右边，从内存中读数据。
  - 不断给指针赋值，就是在不停的改变指针的指向。
  - `p++`只改变指针指向，不改变内存。
  - 指针的数据类型是指它指向的内存空间的指针类型。

## 野指针

  - `free`后一定要重新给指针赋值`NULL`，`free`不改变指针变量的值，只释放内存，不重置指针产生野指针。

## 字面量
  - 肯定不在堆也不在栈！！不知道在代码区还是静态常量区。

## 指针应用条件
  - 定义两个变量实参（需要在操作的值）和形参（辅助修改的值）； `int a;int *p = NULL;`
  - 参数指定（用形参代替实参）. `p =&a;`
  - 使用形参修改实参。`*p = xx;`

## 字符串
  - `buf[] = "abcd";`
  - `strlen(buf) = 4;`  // 不包括字符数组的"\0"
  - `sizeof(buf) = 5;`  // 字符数组所占内存空间大小，包括结尾的"\0"
  - `p[]` 本质上等与`*p`,` p[]` 中的`p`不能改变，`*p`中的`p`可以改变。

## const
  - `const int a;`和 `int const b;`是一样的。
  - 
   - `const char *p; `  // 指针所指的内存空间不能修改
   - `char * const p;`  // 指针变量本身不能被修改
   - `const char * const p;`  // 指针变量和指针所指的内存空间都不能被修改

## 数组

- 元素类型角度，数组是相同类型的变量的有序集合
- 内存角度，连续的一大片内存空间

- `a[100] = {0};`

- 数组地址   // &a     &a+1 --> 跳了100*4 个字节
- 数组首元素地址  // a   a+1 -->跳了4个字节
- 数组类型
- 数组类型变量
- 数组指针类型
- 数组指针类型变量

## 多维数组本质

|          数组参数          |       等效的指针参数       |
| :------------------------: | :------------------------: |
|   一维数组  `char a[10]`   |       指针 `char *p`       |
|   指针数组 `char *a[10]`   |   指针的指针 `char **p`    |
| 二维数组 `char a\[10][10]` | 数组的指针 `char (*a)[10]` |



### 指针数组的常用应用

- 菜单栏
- 命令行输入

### 指针数组的自我结束能力

- 指针数组结尾元素置`NULL`,用于判断结束
- `char *p[]= {'1111','\0'}` <=>`char *p[]= {'1111',0}`<=>`char *p[]= {'1111',NULL}`

# 结构体

## 结构体类型及变量

- 类型定义、变量定义
- 结构体变量初始化及引用

## 结构体做函数参数

- 结构体做参数
- 结构体指针做参数

## 结构体的深拷贝和浅拷贝

- C提供结构体浅拷贝，即当结构体中有指针指向堆区时，不会申请堆区内存，而是机械的拷贝指针变量的值。
- 如果需要深拷贝，需要自己分配堆区的内存。
- 求结构体成员相对结构体首地址偏移量
- 反之，通过结构体成员地址-偏移量 求结构体首地址

## 文件操作

### 文件分类

- 文本文件（ASCII文件）
- 流文件

### 文件操作

- 字符操作`fgetc()`读一个字符，`fputc()`写一个字符，`feof()`判断文件结束